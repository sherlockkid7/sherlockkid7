---
title: 网页、移动端特效和本地存储
date: 2020-07-06 15:42:22
tags: JS
categories: JS
---

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzgvMTcyOTQxZWY4MzYyZjVkNA?x-oss-process=image/format,png)



## 元素偏移量 offset 系列

### 1.offset 概述

offset系列相关属性可以动态的得到该元素的位置（偏移）、大小等。

1. 获得元素距离带有定位父元素的位置
2. 获得元素自身的大小（宽度高度）
   注意：返回的数值都不带单位

offset 系列常用属性：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200608221513354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200608221433199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center)



### 2.offset 与 style 区别

#### offset

- offset 可以得到任意样式表中的样式值

- offset 系列获得的数值是没有单位的

- offsetWidth 包含padding+border+width

- offsetWidth 等属性是只读属性，只能获取不能赋值

> 所以，我们想要获取元素大小位置，用offset更合适

#### style

- style 只能得到行内样式表中的样式值

- style.width 获得的是带有单位的字符串

- style.width 获得不包含padding和border 的值

- style.width 是可读写属性，可以获取也可以赋值

> 所以，我们想要给元素更改值，则需要用style改变

## 元素可视区 client 系列

使用 client 系列的相关属性来获取元素可视区的相关信息,可以动态的得到该元素的边框大小、元素大小等。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200608221613791.png#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200608221635263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center)
补充的知识点：

- 立即执行函数 (function() {})() 或者 (function(){}())
  主要作用： 创建一个独立的作用域。 避免了命名冲突问题

- mouseenter 和mouseover的区别
  mouseenter 鼠标事件：当鼠标移动到元素上时就会触发 mouseenter 事件
  1.mouseover 鼠标经过自身盒子会触发，经过子盒子还会触发。 mouseenter 只会经过自身盒子触发，因为mouseenter不会冒泡
  2.跟mouseenter搭配 ，鼠标离开 mouseleave 同样不会冒泡

- **淘宝 flexible.js 源码分析**

  下面三种情况都会刷新页面都会触发 load 事件。
  1.a标签的超链接
  2.F5或者刷新按钮（强制刷新）
  3.前进后退按钮
  但是 火狐中，有个“往返缓存”，这个缓存中不仅保存着页面数据，还保存了DOM和JavaScript的状态；实际上是将整个页面都保存在了内存里。所以此时后退按钮不能刷新页面。
  此时可以使用 pageshow事件来触发，这个事件在页面显示时触发，无论页面是否来自缓存。在重新加载页面中，pageshow会在load事件触发后触发；根据事件对象中的persisted来判断是否是缓存中的页面触发的pageshow事件,`注意这个事件给window添加。`

  ```js
  (function flexible(window, document) {
      // 获取的html 的根元素
      var docEl = document.documentElement
          // dpr 物理像素比
      var dpr = window.devicePixelRatio || 1
  
      // adjust body font size  设置我们body 的字体大小
      function setBodyFontSize() {
          // 如果页面中有body 这个元素 就设置body的字体大小
          if (document.body) {
              document.body.style.fontSize = (12 * dpr) + 'px'
          } else {
              // 如果页面中没有body 这个元素，则等着 我们页面主要的DOM元素加载完毕再去设置body
              // 的字体大小
              document.addEventListener('DOMContentLoaded', setBodyFontSize)
          }
      }
      setBodyFontSize();
  
      // set 1rem = viewWidth / 10    设置我们html 元素的文字大小,让网页根据html元素的文字大小实现适配
      function setRemUnit() {
          var rem = docEl.clientWidth / 10
          docEl.style.fontSize = rem + 'px'
      }
  
      setRemUnit()
  
      // reset rem unit on page resize  当我们页面尺寸大小发生变化的时候，要重新设置下rem 的大小
      window.addEventListener('resize', setRemUnit)
          // pageshow 是我们重新加载页面触发的事件
      window.addEventListener('pageshow', function(e) {
          // e.persisted 返回的是true 就是说如果这个页面是从缓存取过来的页面，也需要从新计算一下rem 的大小
          if (e.persisted) {
              setRemUnit()
          }
      })
  
      // detect 0.5px supports  有些移动端的浏览器不支持0.5像素的写法
      if (dpr >= 2) {
          var fakeBody = document.createElement('body')
          var testElement = document.createElement('div')
          testElement.style.border = '.5px solid transparent'
          fakeBody.appendChild(testElement)
          docEl.appendChild(fakeBody)
          if (testElement.offsetHeight === 1) {
              docEl.classList.add('hairlines')
          }
          docEl.removeChild(fakeBody)
      }
  }(window, document))
  ```

## **元素滚动 scroll 系列**

使用 scroll 系列的相关属性可以动态的得到该元素的大小、滚动距离等
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200608221713881.png#pic_center)
注意事项：

1. 页面滚动事件 scroll  因为是页面滚动，所以事件源是document
2. **页面被卷去的头部**：可以通过**window.pageYOffset** 获得  ，如果是被卷去的左侧：可以通过window.pageXOffset获得
3. **元素**被卷去的头部是**element.scrollTop**  

**页面被卷去的头部兼容性解决方案**
通常有如下几种写法：

1. 声明了 DTD，使用 document.documentElement.scrollTop
2. 未声明 DTD，使用  document.body.scrollTop
3. 新方法 window.pageYOffset和 window.pageXOffset，IE9 开始支持

```js
function getScroll() {
    return {
      left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft||0,
      top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
    };
 } 
使用的时候  getScroll().left
```



## 三大系列总结

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200608222716986.png#pic_center)
主要用法：
1.**offset** 经常用于获得**元素位置**    offsetLeft  offsetTop
2.**client** 经常用于获取**元素大小**  clientWidth clientHeight
3.**scroll** 经常用于获取**滚动距离** scrollTop  scrollLeft  
4.**页面**滚动的距离通过 **window.pageYOffset**、window.pageXOffset  获得
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200608223520818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center)

## 触屏事件

常见的触屏事件如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200608223801789.png#pic_center)
**触摸事件对象（TouchEvent）**
是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件
重点触摸事件对象列表：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200608223937929.png#pic_center)
因为平时我们都是给元素注册触摸事件，所以重点记住 **targetTocuhes**
**移动端拖动元素**

1. touchstart、touchmove、touchend 可以实现拖动元素
2. 但是拖动元素需要当前手指的坐标值 我们可以使用 **targetTouches[0]** 里面的**pageX** 和 **pageY** 
3. 移动端拖动的原理： 手指移动中，计算出手指移动的距离。然后用盒子原来的位置 + 手指移动的距离
4. 手指移动的距离： 手指滑动中的位置 减去 手指刚开始触摸的位置
   拖动元素三步曲：
   （1） 触摸元素 touchstart： 获取手指初始坐标，同时获得盒子原来的位置
   （2） 移动手指 touchmove： 计算手指的滑动距离，并且移动盒子
   （3） 离开手指 touchend:
   **注意： 手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动 e.preventDefault();**

**补充知识点**：
 **classList 属性**
classList属性是HTML5新增的一个属性，返回元素的类名。ie10以上版本支持。
该属性用于在元素中添加、移除及切换 CSS 类。

- **添加类：**
  element.classList.add（’类名’）；

```javascript
focus.classList.add('current');
```

- **移除类：**
  element.classList.remove（’类名’）;

```javascript
focus.classList.remove('current');
```

- **切换类：**
  element.classList.toggle（’类名’）;

```javascript
focus.classList.toggle('current');
```

`注意:以上方法里面，所有类名都不带点`

**click 延时解决方案**
移动端 click 事件会有 300ms 的延时，原因是移动端屏幕双击会缩放(double tap to zoom) 页面。
解决方案：
1.禁用缩放。 浏览器禁用默认的双击缩放行为并且去掉 300ms 的点击延迟。

```
<meta name="viewport" content="user-scalable=no">
```


2.使用插件。 fastclick 插件解决 300ms 延迟。

```
document.addEventListener('DOMContentLoaded',function () {
/*等页面文档加载完成 不需要等所有的资源*/
FastClick.attach(document.body);
});
```

## 本地存储

### 1.特点

1、数据存储在用户浏览器中
2、设置、读取方便、甚至页面刷新不丢失数据
3、容量较大，sessionStorage约5M、localStorage约20M
4、只能存储字符串，可以将对象JSON.stringify() 编码后存储

### 2.window.sessionStorage

1、生命周期为关闭浏览器窗口
2、在同一个窗口(页面)下数据可以共享
3、以键值对的形式存储使用

存储数据：

```javascript
sessionStorage.setItem(key, value)
```

获取数据：

```javascript
sessionStorage.getItem(key)
```

删除数据：

```javascript
sessionStorage.removeItem(key)
```

清空数据：(所有都清除掉)

```javascript
sessionStorage.clear()
```

### 3.window.localStorage

1、声明周期永久生效，除非手动删除 否则关闭页面也会存在
2、可以多窗口（页面）共享（同一浏览器可以共享）

3、以键值对的形式存储使用

存储数据：

```javascript
localStorage.setItem(key, value)
```

获取数据：

```javascript
localStorage.getItem(key)
```

删除数据：

```javascript
localStorage.removeItem(key)
```

清空数据：(所有都清除掉)

```javascript
localStorage.clear()
```