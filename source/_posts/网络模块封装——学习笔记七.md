---
title: 网络模块封装——学习笔记七
date: 2020-06-20 16:36:52
tags: vue axios
categories: Vue
---

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200620163955194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center)

## 网络请求模式

1.传统的Ajax（基于XMLHttpRequest(XHR)）

2.jQuery-Ajax

3.axios

## 认识axios

### axios请求方式

axios(config)
axios.request(config)
axios.get(url[, config])
axios.delete(url[, config])
axios.head(url[, config])
axios.post(url[, data[, config]])
axios.put(url[, data[, config]])
axios.patch(url[, data[, config]])

```js
//发送get请求(app.vue)
import axios from 'axios'
export default {
  name: 'App',
  created(){
    // 1.没有请求参数
    axios.get('http://123.207.32.32:8000/home/multidata')
    .then(res => {
      console.log(res);
    }).catch(err => {
      console.log(err); 
    })

     // 2.有请求参数
     axios.get('http://123.207.32.32:8000/home/data',{params:{type:'sell',page:1}})
     .then(res => {
       console.log(res);
     }).catch(err => {
       console.log(err); 
     })
  }

}
```

## 发送基本请求

### 1.发送并发请求(同时发送多个请求)

使用axios.all, 可以放入多个请求的数组.
axios.all([]) 返回的结果是一个数组，使用 axios.spread 可将数组 [res1,res2] 展开为 res1, res2

```js
import axios from 'axios'
export default {
  name: 'App',
  created(){
    // 发送并发请求
    axios.all(
      [
        axios.get('http://123.207.32.32:8000/home/multidata'),
        axios.get('http://123.207.32.32:8000/category')      
      ])
      .then(axios.spread((res1,res2)=>{
        console.log(res1);
        console.log(res2);     
      }))
  }
}
```

### 2.全局配置

在开发中可能很多参数都是固定的.这个时候我们可以进行一些抽取, 也可以利用axios的全局配置

axios.defaults.baseURL = ‘123.207.32.32:8000’
axios.defaults.headers.post[‘Content-Type’] = ‘application/x-www-form-urlencoded’;

```js
import axios from 'axios'
export default {
  name: 'App',
  created(){
    //提取全局的配置
    axios.defaults.baseURL = 'http://123.207.32.32:8000'
    // 发送并发请求
    axios.all(
      [
        axios.get('/home/multidata'),
        axios.get('/category')      
      ])
      .then(axios.spread((res1,res2)=>{
        console.log(res1);
        console.log(res2);     
      }))
  }
}
```

### 3.常见的配置选项

- 请求地址
  url: '/user',
- 请求类型
  method: 'get',
- 请根路径
  baseURL: 'http://www.mt.com/api',
- 请求前的数据处理
  transformRequest:[function(data){}],
- 请求后的数据处理
  transformResponse: [function(data){}],
- 自定义的请求头
  headers:{'x-Requested-With':'XMLHttpRequest'},
- URL查询对象
  params:{ id: 12 },
- 查询对象序列化函数
  paramsSerializer: function(params){ }
  request body
  data: { key: 'aa'},
- 超时设置s
  timeout: 1000,
- 跨域是否带Token
  withCredentials: false,
- 自定义请求处理
  adapter: function(resolve, reject, config){},
- 身份验证信息
  auth: { uname: '', pwd: '12'},
- 响应的数据格式 json / blob /document /arraybuffer / text / stream
  responseType: 'json',

## axios实例

src目录下新建network文件夹，并在该文件夹下新建request.js，封装axios模块

```js
import axios from 'axios'
 一、回调函数的方式
export function request(config,success,failure){ 
  // 1.创建axios的实例
  const instance = axios.create({
    baseURL:'http://123.207.32.32:8000',
    timeout:5000
  })
  // 2.发送真正的网络请求
  instance(config)
  .then(res => {
    success(res);
  })
  .catch(err => {
    failure(err);
  })
}
 二、promise的方式
 export function request(config){ 
  return new promise((resolve,reject) => {
      // 1.创建axios的实例
      const instance = axios.create({
        baseURL:'http://123.207.32.32:8000',
        timeout:5000
      })
      // 2.发送真正的网络请求
      instance(config)
      .then(res => {
        resolve(res);
      })
      .catch(err => {
        reject(err);
      })
  })
}
三、最简单的封装
 export function request(config){ 
      // 1.创建axios的实例
      const instance = axios.create({
        baseURL:'http://123.207.32.32:8000',
        timeout:5000
      })
      // 2.发送真正的网络请求
      return instance(config) //instance(config) 直接返回的是promise
}
```

在需要的位置使用封装的网络请求模块

```js
// request模块
import {request} from './network/request.js'
export default {
  name: 'App',
  created(){
   一、回调函数的方式
   request({
     url:'/home/multidata'
   },res => {
     console.log(res);  
   },err => {
     console.log(err);
   })
   二、promise的方式(第三种方式同样)
    request({
     url:'/home/multidata'
   }).then (res =>{
       console.log(res);
    }).catch(err => {
      console.log(err);
    })
  }
}
```

## 拦截器

用于我们在发送每次请求或者得到相应后，进行对应的处理。

- 请求拦截的作用：

  - 当发送网络请求时，在页面中添加一个loading组件，作为动画

  - 某些请求要求用户必须登录，判断用户是否有token,如果没有token就跳转到login页面

  - config中的一些信息不符合服务器要求

    请求拦截中错误拦截较少，通常都是配置相关的拦截
    可能的错误比如请求超时，可以将页面跳转到一个错误页面中。

- 响应拦截中完成的事情：
  - 响应的成功拦截中，主要是对数据进行过滤。
  - 响应的失败拦截中，可以根据status判断报错的错误码，跳转到不同的错误提示页面。

```js
// axios拦截器：配置请求和响应拦截
  instance.interceptors.request.use(config => {
    // 请求拦截：success中
    return config  //拦截了需要返回
  },err => {
    // 请求拦截：failure中
    return err  
  })

  instance.interceptors.response.use(response => {
    // 响应拦截：success中
    return response.data
  },err => {
    // 响应拦截：failure中
    if(err && err.response){
      switch (err.response.status){
        case 400:
          err.message = '请求错误'
          break
        case 401:
          err.message = '未授权的访问'
          break
      }
    }
    return err  
  })
```

